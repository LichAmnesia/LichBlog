---
title: 二分图匹配算法总结
date: 2014-01-26 11:18:16
tags:
---

 

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">二分图最大匹配的匈牙利算法</span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">二分图是这样一个图，它的顶点可以分类两个集合<span style="line-height: 21px;">X</span><span style="font-family: 宋体; line-height: 21px;">和</span><span style="line-height: 21px;">Y</span><span style="font-family: 宋体; line-height: 21px;">，所有的边关联在两个顶点中，恰好一个属于集合Ｘ，另一个属于集合Ｙ。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">最大匹配：</span><span style="font-family: 'Times New Roman'; font-size: 10.5pt;">图中包含边数最多的匹配称为图的最大匹配。</span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">完美匹配：</span><span style="font-family: 'Times New Roman'; font-size: 10.5pt;">如果所有点都在匹配边上，称这个最大匹配是完美匹配。 </span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">最小覆盖：</span><span style="font-family: 'Times New Roman'; font-size: 10.5pt;"> </span><span style="font-family: 'Times New Roman'; font-size: 10.5pt;">最小覆盖要求用最少的点（Ｘ集合或Ｙ集合的都行）让每条边都至少和其中一个点关联。可以证明：最少的点（即覆盖数）＝最大匹配数 </span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">最小路径覆盖： </span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">用尽量少的不相交简单路径覆盖有向无环图Ｇ的所有结点。解决此类问题可以建立一个二分图模型。把所有顶点<span style="line-height: 21px;">i</span><span style="font-family: 宋体; line-height: 21px;">拆成两个：Ｘ结点集中的</span><span style="line-height: 21px;">i</span><span style="font-family: 宋体; line-height: 21px;">和</span><span style="line-height: 21px;">Y</span><span style="font-family: 宋体; line-height: 21px;">结点集中的</span><span style="line-height: 21px;">i&#39;,</span><span style="font-family: 宋体; line-height: 21px;">如果有边</span><span style="line-height: 21px;">i->j</span><span style="font-family: 宋体; line-height: 21px;">，则在二分图中引入边</span><span style="line-height: 21px;">i->j&#39;</span><span style="font-family: 宋体; line-height: 21px;">，设二分图最大匹配为</span><span style="line-height: 21px;">m,</span><span style="font-family: 宋体; line-height: 21px;">则结果就是</span><span style="line-height: 21px;">n-m</span><span style="font-family: 宋体; line-height: 21px;">。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">最大独立集问题： </span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">在Ｎ个点的图<span style="line-height: 21px;">G</span><span style="font-family: 宋体; line-height: 21px;">中选出</span><span style="line-height: 21px;">m</span><span style="font-family: 宋体; line-height: 21px;">个点，使这</span><span style="line-height: 21px;">m</span><span style="font-family: 宋体; line-height: 21px;">个点两两之间没有边．求</span><span style="line-height: 21px;">m</span><span style="font-family: 宋体; line-height: 21px;">最大值．</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">如果图Ｇ满足二分图条件，则可以用二分图匹配来做．最大独立集点数 <span style="line-height: 21px;">= N - </span><span style="font-family: 宋体; line-height: 21px;">最大匹配数</span></span>

	**<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">一、</span><span style="font-family: 'Times New Roman'; font-size: 10.5pt;">匈牙利算法</span>**

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">设<span style="line-height: 21px;">G=(V,{R})</span><span style="font-family: 宋体; line-height: 21px;">是一个无向图。如顶点集</span><span style="line-height: 21px;">V</span><span style="font-family: 宋体; line-height: 21px;">可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属两个不同的子集。则称图</span><span style="line-height: 21px;">G</span><span style="font-family: 宋体; line-height: 21px;">为二分图。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">   v       <span style="font-family: 宋体; line-height: 21px;">给定一个二分图</span><span style="line-height: 21px;">G</span><span style="font-family: 宋体; line-height: 21px;">，在</span><span style="line-height: 21px;">G</span><span style="font-family: 宋体; line-height: 21px;">的一个子图</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">中，</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">的边集</span><span style="line-height: 21px;">{E}</span><span style="font-family: 宋体; line-height: 21px;">中的任意两条边都不依附于同一个顶点，则称</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">是一个匹配。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       <span style="font-family: 宋体; line-height: 21px;">选择这样的边数最大的子集称为图的最大匹配问题</span><span style="line-height: 21px;">(maximal matching problem)</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       <span style="font-family: 宋体; line-height: 21px;">如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完全匹配，也称作完备匹配。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">最大匹配在实际中有广泛的用处，求最大匹配的一种显而易见的算法是：先找出全部匹配，然后保留匹配数最多的。但是这个算法的复杂度为边数的指数级函数。因此，需要寻求一种更加高效的算法。</span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">匈牙利算法是求解最大匹配的有效算法，该算法用到了增广路的定义<span style="line-height: 21px;">(</span><span style="font-family: 宋体; line-height: 21px;">也称增广轨或交错轨</span><span style="line-height: 21px;">)</span><span style="font-family: 宋体; line-height: 21px;">：若</span><span style="line-height: 21px;">P</span><span style="font-family: 宋体; line-height: 21px;">是图</span><span style="line-height: 21px;">G</span><span style="font-family: 宋体; line-height: 21px;">中一条连通两个未匹配顶点的路径，并且属</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">的边和不属</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">的边</span><span style="line-height: 21px;">(</span><span style="font-family: 宋体; line-height: 21px;">即已匹配和待匹配的边</span><span style="line-height: 21px;">)</span><span style="font-family: 宋体; line-height: 21px;">在</span><span style="line-height: 21px;">P</span><span style="font-family: 宋体; line-height: 21px;">上交替出现，则称</span><span style="line-height: 21px;">P</span><span style="font-family: 宋体; line-height: 21px;">为相对于</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">的一条增广路径。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">由增广路径的定义可以推出下述三个结论：</span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       1.   P<span style="font-family: 宋体; line-height: 21px;">的路径长度必定为奇数，第一条边和最后一条边都不属于</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       2.   P<span style="font-family: 宋体; line-height: 21px;">经过取反操作（即非</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">中的边变为</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">中的边，原来</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">中的边去掉）可以得到一个更大的匹配</span><span style="line-height: 21px;">M&rsquo;</span><span style="font-family: 宋体; line-height: 21px;">。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       3.   M<span style="font-family: 宋体; line-height: 21px;">为</span><span style="line-height: 21px;">G</span><span style="font-family: 宋体; line-height: 21px;">的最大匹配当且仅当不存在相对于</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">的增广路径。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">从而可以得到求解最大匹配的匈牙利算法：</span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       (1)<span style="font-family: 宋体; line-height: 21px;">置</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">为空</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       (2)<span style="font-family: 宋体; line-height: 21px;">找出一条增广路径</span><span style="line-height: 21px;">P</span><span style="font-family: 宋体; line-height: 21px;">，通过取反操作获得更大的匹配</span><span style="line-height: 21px;">M&rsquo;</span><span style="font-family: 宋体; line-height: 21px;">代替</span><span style="line-height: 21px;">M</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       (3)<span style="font-family: 宋体; line-height: 21px;">重复</span><span style="line-height: 21px;">(2)</span><span style="font-family: 宋体; line-height: 21px;">操作直到找不出增广路径为止</span></span>

	**<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">二、<span style="line-height: 21px;">KM</span><span style="font-family: 宋体; line-height: 21px;">算法：</span></span>**

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">二分图最优匹配：对于二分图的每条边都有一个权（非负），要求一种完备匹配方案，使得所有匹配边的权和最大，记做最优完备匹配。（特殊的，当所有边的权为<span style="line-height: 21px;">1</span><span style="font-family: 宋体; line-height: 21px;">时，就是最大完备匹配问题）</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">解二分图最优匹配问题可用穷举的方法，但穷举的效率<span style="line-height: 21px;">=n</span><span style="font-family: 宋体; line-height: 21px;">！，所以我们需要更加优秀的算法。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">先说一个定理：设<span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">是一个带权完全二分图</span><span style="line-height: 21px;">G</span><span style="font-family: 宋体; line-height: 21px;">的一个完备匹配，给每个顶点一个可行顶标</span><span style="line-height: 21px;">(</span><span style="font-family: 宋体; line-height: 21px;">第</span><span style="line-height: 21px;">i</span><span style="font-family: 宋体; line-height: 21px;">个</span><span style="line-height: 21px;">x</span><span style="font-family: 宋体; line-height: 21px;">顶点的可行标用</span><span style="line-height: 21px;">lx[i]</span><span style="font-family: 宋体; line-height: 21px;">表示，第</span><span style="line-height: 21px;">j</span><span style="font-family: 宋体; line-height: 21px;">个</span><span style="line-height: 21px;">y</span><span style="font-family: 宋体; line-height: 21px;">顶点的可行标用</span><span style="line-height: 21px;">ly[j]</span><span style="font-family: 宋体; line-height: 21px;">表示</span><span style="line-height: 21px;">)</span><span style="font-family: 宋体; line-height: 21px;">，如果对所有的边</span><span style="line-height: 21px;">(i,j) in G,</span><span style="font-family: 宋体; line-height: 21px;">都有</span><span style="line-height: 21px;">lx[i]+ly[j]>=w[i,j]</span><span style="font-family: 宋体; line-height: 21px;">成立</span><span style="line-height: 21px;">(w[i,j]</span><span style="font-family: 宋体; line-height: 21px;">表示边的权</span><span style="line-height: 21px;">)</span><span style="font-family: 宋体; line-height: 21px;">，且对所有的边</span><span style="line-height: 21px;">(i,j) in M,</span><span style="font-family: 宋体; line-height: 21px;">都有</span><span style="line-height: 21px;">lx[i]+ly[j]=w[i,j]</span><span style="font-family: 宋体; line-height: 21px;">成立，则</span><span style="line-height: 21px;">M</span><span style="font-family: 宋体; line-height: 21px;">是图</span><span style="line-height: 21px;">G</span><span style="font-family: 宋体; line-height: 21px;">的一个最优匹配。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">Kuhn<span style="font-family: 宋体; line-height: 21px;">－</span><span style="line-height: 21px;">Munkras</span><span style="font-family: 宋体; line-height: 21px;">算法（即</span><span style="line-height: 21px;">KM</span><span style="font-family: 宋体; line-height: 21px;">算法）流程：</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       (1)<span style="font-family: 宋体; line-height: 21px;">初始化可行顶标的值</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       (2)<span style="font-family: 宋体; line-height: 21px;">用匈牙利算法寻找完备匹配</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       (3)<span style="font-family: 宋体; line-height: 21px;">若未找到完备匹配则修改可行顶标的值</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">v       (4)<span style="font-family: 宋体; line-height: 21px;">重复</span><span style="line-height: 21px;">(2)(3)</span><span style="font-family: 宋体; line-height: 21px;">直到找到相等子图的完备匹配为止</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">KM<span style="font-family: 宋体; line-height: 21px;">算法主要就是控制怎样修改可行顶标的策略使得最终可以达到一个完美匹配，首先任意设置可行顶标（如每个</span><span style="line-height: 21px;">X</span><span style="font-family: 宋体; line-height: 21px;">节点的可行顶标设为它出发的所有弧的最大权，</span><span style="line-height: 21px;">Y</span><span style="font-family: 宋体; line-height: 21px;">节点的可行顶标设为</span><span style="line-height: 21px;">0</span><span style="font-family: 宋体; line-height: 21px;">），然后在相等子图中寻找增广路，找到增广路就沿着增广路增广。而如果没有找到增广路呢，那么就考虑所有现在在匈牙利树中的</span><span style="line-height: 21px;">X</span><span style="font-family: 宋体; line-height: 21px;">节点（记为</span><span style="line-height: 21px;">S</span><span style="font-family: 宋体; line-height: 21px;">集合），所有现在在匈牙利树中的</span><span style="line-height: 21px;">Y</span><span style="font-family: 宋体; line-height: 21px;">节点（记为</span><span style="line-height: 21px;">T</span><span style="font-family: 宋体; line-height: 21px;">集合），考察所有一段在</span><span style="line-height: 21px;">S</span><span style="font-family: 宋体; line-height: 21px;">集合，一段在</span><span style="line-height: 21px;">not T</span><span style="font-family: 宋体; line-height: 21px;">集合中的弧，取       </span><span style="line-height: 21px;">delta = min {l(xi)+l(yj)-w(xi,yj) , | xi in S, yj   in not T}    </span><span style="font-family: 宋体; line-height: 21px;">。明显的，当我们把所有</span><span style="line-height: 21px;">S</span><span style="font-family: 宋体; line-height: 21px;">集合中的</span><span style="line-height: 21px;">l(xi)</span><span style="font-family: 宋体; line-height: 21px;">减少</span><span style="line-height: 21px;">delta</span><span style="font-family: 宋体; line-height: 21px;">之后，一定会有至少一条属于</span><span style="line-height: 21px;">(S, not T)</span><span style="font-family: 宋体; line-height: 21px;">的边进入相等子图，进而可以继续扩展匈牙利树，为了保证原来属于</span><span style="line-height: 21px;">(S,T )</span><span style="font-family: 宋体; line-height: 21px;">的边不退出相等子图，把所有在</span><span style="line-height: 21px;">T</span><span style="font-family: 宋体; line-height: 21px;">集合中的点的可行顶标增加</span><span style="line-height: 21px;">delta</span><span style="font-family: 宋体; line-height: 21px;">。随后匈牙利树继续扩展，如果新加入匈牙利树的</span><span style="line-height: 21px;">Y</span><span style="font-family: 宋体; line-height: 21px;">节点是未盖点，那么找到增广路，否则把该节点的对应的</span><span style="line-height: 21px;">X</span><span style="font-family: 宋体; line-height: 21px;">匹配点加入匈牙利树继续尝试增广。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">复杂度分析：由于在不扩大匹配的情况下每次匈牙利树做如上调整之后至少增加一个元素，因此最多执行<span style="line-height: 21px;">n</span><span style="font-family: 宋体; line-height: 21px;">次就可以找到一条增广路，最多需要找</span><span style="line-height: 21px;">n</span><span style="font-family: 宋体; line-height: 21px;">条增广路，故最多执行</span><span style="line-height: 21px;">n^2</span><span style="font-family: 宋体; line-height: 21px;">次修改顶标的操作，而每次修改顶标需要扫描所有弧，这样修改顶标的复杂度就是</span><span style="line-height: 21px;">O(n^2)</span><span style="font-family: 宋体; line-height: 21px;">的，总的复杂度是</span><span style="line-height: 21px;">O(n^4)</span><span style="font-family: 宋体; line-height: 21px;">的。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">     对于<span style="line-height: 21px;">not T</span><span style="font-family: 宋体; line-height: 21px;">的每个元素</span><span style="line-height: 21px;">yj</span><span style="font-family: 宋体; line-height: 21px;">，定义松弛变量</span><span style="line-height: 21px;">slack(yj) =min{l(xi)+l(yj)-w(xi,yj), | xi in S}</span><span style="font-family: 宋体; line-height: 21px;">，很明显每次的</span><span style="line-height: 21px;">delta = min{slack(yj), | yj   in not T}</span><span style="font-family: 宋体; line-height: 21px;">，每次增广之后用</span><span style="line-height: 21px;">O(n^2)</span><span style="font-family: 宋体; line-height: 21px;">的时间计算所有点的初始</span><span style="line-height: 21px;">slack</span><span style="font-family: 宋体; line-height: 21px;">，由于生长匈牙利树的时候每条弧的顶标增量相同，因此修改每个</span><span style="line-height: 21px;">slack</span><span style="font-family: 宋体; line-height: 21px;">需要常数时间（注意在修改顶标后和把已盖</span><span style="line-height: 21px;">Y</span><span style="font-family: 宋体; line-height: 21px;">节点对应的</span><span style="line-height: 21px;">X</span><span style="font-family: 宋体; line-height: 21px;">节点加入匈牙利树的时候是需要修改</span><span style="line-height: 21px;">slack</span><span style="font-family: 宋体; line-height: 21px;">的）。这样修改所有</span><span style="line-height: 21px;">slack</span><span style="font-family: 宋体; line-height: 21px;">值时间是</span><span style="line-height: 21px;">O(n)</span><span style="font-family: 宋体; line-height: 21px;">的，每次增广后最多修改</span><span style="line-height: 21px;">n</span><span style="font-family: 宋体; line-height: 21px;">次顶标，那么修改顶标的总时间降为</span><span style="line-height: 21px;">O(n^2)</span><span style="font-family: 宋体; line-height: 21px;">，</span><span style="line-height: 21px;">n</span><span style="font-family: 宋体; line-height: 21px;">次增广的总时间复杂度降为</span><span style="line-height: 21px;">O(n^3)</span><span style="font-family: 宋体; line-height: 21px;">。事实上这样实现之后对于大部分的数据可以比</span><span style="line-height: 21px;">O(n^4)</span><span style="font-family: 宋体; line-height: 21px;">的算法快一倍左右。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">利用二分图匹配的匈牙利算法和<span style="line-height: 21px;">KM</span><span style="font-family: 宋体; line-height: 21px;">算法，我们可以求解大部分的关于二分图的问题，它们提供了求解最大匹配和最优匹配的有效算法，在具体编程时我们只要多注意优化，我们就可以得出求解这类问题的有效方法，从而可以对这类实际问题进行有效合理的解决。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">另一种说法：</span>

	[KM算法(转)](http://www.cnblogs.com/zhuangli/archive/2008/08/03/1259248.html)

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">      </span><span style="font-family: 'Times New Roman'; font-size: 10.5pt;">KM<span style="font-family: 宋体; line-height: 21px;">算法是通过给每个顶点一个标号（叫做顶标）来把求最大权匹配的问题转化为求完备匹配的问题的。设顶点</span><span style="line-height: 21px;">Xi</span><span style="font-family: 宋体; line-height: 21px;">的顶标为</span><span style="line-height: 21px;">A[i]</span><span style="font-family: 宋体; line-height: 21px;">，顶点</span><span style="line-height: 21px;">Yi</span><span style="font-family: 宋体; line-height: 21px;">的顶标为</span><span style="line-height: 21px;">B [i]</span><span style="font-family: 宋体; line-height: 21px;">，顶点</span><span style="line-height: 21px;">Xi</span><span style="font-family: 宋体; line-height: 21px;">与</span><span style="line-height: 21px;">Yj</span><span style="font-family: 宋体; line-height: 21px;">之间的边权为</span><span style="line-height: 21px;">w[i,j]</span><span style="font-family: 宋体; line-height: 21px;">。在算法执行过程中的任一时刻，对于任一条边</span><span style="line-height: 21px;">(i,j)</span><span style="font-family: 宋体; line-height: 21px;">，</span><span style="line-height: 21px;">A[i]+B[j]>=w[i,j]</span><span style="font-family: 宋体; line-height: 21px;">始终 成立。</span><span style="line-height: 21px;">KM</span><span style="font-family: 宋体; line-height: 21px;">算法的正确性基于以下定理：</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;"> 　　</span><span style="font-family: 'Times New Roman'; font-size: 10.5pt;">若由二分图中所有满足<span style="line-height: 21px;">A[i]+B[j]=w[i,j]</span><span style="font-family: 宋体; line-height: 21px;">的边</span><span style="line-height: 21px;">(i,j)</span><span style="font-family: 宋体; line-height: 21px;">构成的子图（称做相等子图）有完备匹配，那么这个完备匹配就是二分图的最大权匹配。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;">　　这个定理是显然的。因为对于二分图的任意一个匹配，如果它包含于相等子图，那么它的边权和等于所有顶点的顶标和；如果它有的边不包含于相等子图，那么它的边权和小于所有顶点的顶标和。所以相等子图的完备匹配一定是二分图的最大权匹配。</span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;"> 　　初始时为了使<span style="line-height: 21px;">A[i]+B[j]>=w[i,j]</span><span style="font-family: 宋体; line-height: 21px;">恒成立，令</span><span style="line-height: 21px;">A[i]</span><span style="font-family: 宋体; line-height: 21px;">为所有与顶点</span><span style="line-height: 21px;">Xi</span><span style="font-family: 宋体; line-height: 21px;">关联的边的最大权，</span><span style="line-height: 21px;">B[j]=0</span><span style="font-family: 宋体; line-height: 21px;">。如果当前的相等子图没有完备匹配，就按下面的方法修改顶标以使扩大相等子图，直到相等子图具有完备匹配为止。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;"> 　　我们求当前相等子图的完备匹配失败了，是因为对于某个<span style="line-height: 21px;">X</span><span style="font-family: 宋体; line-height: 21px;">顶点，我们找不到一条从它出发的交错路。这时我们获得了一棵交错树，它的叶子结点全部是</span><span style="line-height: 21px;">X</span><span style="font-family: 宋体; line-height: 21px;">顶点。现在我们把交错树中</span><span style="line-height: 21px;">X</span><span style="font-family: 宋体; line-height: 21px;">顶点的顶标全都减小某个值</span><span style="line-height: 21px;">d</span><span style="font-family: 宋体; line-height: 21px;">，</span><span style="line-height: 21px;">Y</span><span style="font-family: 宋体; line-height: 21px;">顶点的顶标全都增加同一个值</span><span style="line-height: 21px;">d</span><span style="font-family: 宋体; line-height: 21px;">，那么我们会发现：</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;"> 两端都在交错树中的边<span style="line-height: 21px;">(i,j)</span><span style="font-family: 宋体; line-height: 21px;">，</span><span style="line-height: 21px;">A[i]+B[j]</span><span style="font-family: 宋体; line-height: 21px;">的值没有变化。也就是说，它原来属于相等子图，现在仍属于相等子图。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;"> 两端都不在交错树中的边<span style="line-height: 21px;">(i,j)</span><span style="font-family: 宋体; line-height: 21px;">，</span><span style="line-height: 21px;">A[i]</span><span style="font-family: 宋体; line-height: 21px;">和</span><span style="line-height: 21px;">B[j]</span><span style="font-family: 宋体; line-height: 21px;">都没有变化。也就是说，它原来属于（或不属于）相等子图，现在仍属于（或不属于）相等子图。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;"> X<span style="font-family: 宋体; line-height: 21px;">端不在交错树中，</span><span style="line-height: 21px;">Y</span><span style="font-family: 宋体; line-height: 21px;">端在交错树中的边</span><span style="line-height: 21px;">(i,j)</span><span style="font-family: 宋体; line-height: 21px;">，它的</span><span style="line-height: 21px;">A[i]+B[j]</span><span style="font-family: 宋体; line-height: 21px;">的值有所增大。它原来不属于相等子图，现在仍不属于相等子图。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;"> X<span style="font-family: 宋体; line-height: 21px;">端在交错树中，</span><span style="line-height: 21px;">Y</span><span style="font-family: 宋体; line-height: 21px;">端不在交错树中的边</span><span style="line-height: 21px;">(i,j)</span><span style="font-family: 宋体; line-height: 21px;">，它的</span><span style="line-height: 21px;">A[i]+B[j]</span><span style="font-family: 宋体; line-height: 21px;">的值有所减小。也就说，它原来不属于相等子图，现在可能进入了相等子图，因而使相等子图得到了扩大。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;"> 　　现在的问题就是求<span style="line-height: 21px;">d</span><span style="font-family: 宋体; line-height: 21px;">值了。为了使</span><span style="line-height: 21px;">A[i]+B[j]>=w[i,j]</span><span style="font-family: 宋体; line-height: 21px;">始终成立，且至少有一条边进入相等子图，</span><span style="line-height: 21px;">d</span><span style="font-family: 宋体; line-height: 21px;">应该等于</span><span style="line-height: 21px;">min{A[i]+B[j]-w[i,j]|Xi</span><span style="font-family: 宋体; line-height: 21px;">在交错树中，</span><span style="line-height: 21px;">Yi</span><span style="font-family: 宋体; line-height: 21px;">不在交错树中</span><span style="line-height: 21px;">}</span><span style="font-family: 宋体; line-height: 21px;">。</span></span>

	<span style="font-family: 'Times New Roman'; font-size: 10.5pt;"> 　　以上就是<span style="line-height: 21px;">KM</span><span style="font-family: 宋体; line-height: 21px;">算法的基本思路。但是朴素的实现方法，时间复杂度为</span><span style="line-height: 21px;">O(n4)&mdash;&mdash;</span><span style="font-family: 宋体; line-height: 21px;">需要找</span><span style="line-height: 21px;">O(n)</span><span style="font-family: 宋体; line-height: 21px;">次增广路，每次增广最多需要修改</span><span style="line-height: 21px;">O(n)</span><span style="font-family: 宋体; line-height: 21px;">次顶 标，每次修改顶标时由于要枚举边来求</span><span style="line-height: 21px;">d</span><span style="font-family: 宋体; line-height: 21px;">值，复杂度为</span><span style="line-height: 21px;">O(n2)</span><span style="font-family: 宋体; line-height: 21px;">。实际上</span><span style="line-height: 21px;">KM</span><span style="font-family: 宋体; line-height: 21px;">算法的复杂度是可以做到</span><span style="line-height: 21px;">O(n3)</span><span style="font-family: 宋体; line-height: 21px;">的。我们给每个</span><span style="line-height: 21px;">Y</span><span style="font-family: 宋体; line-height: 21px;">顶点一个</span><span style="line-height: 21px;">"</span><span style="font-family: 宋体; line-height: 21px;">松弛量</span><span style="line-height: 21px;">"</span><span style="font-family: 宋体; line-height: 21px;">函数 </span><span style="line-height: 21px;">slack</span><span style="font-family: 宋体; line-height: 21px;">，每次开始找增广路时初始化为无穷大。在寻找增广路的过程中，检查边</span><span style="line-height: 21px;">(i,j)</span><span style="font-family: 宋体; line-height: 21px;">时，如果它不在相等子图中，则让</span><span style="line-height: 21px;">slack[j]</span><span style="font-family: 宋体; line-height: 21px;">变成原值与</span><span style="line-height: 21px;">A [i]+B[j]-w[i,j]</span><span style="font-family: 宋体; line-height: 21px;">的较小值。这样，在修改顶标时，取所有不在交错树中的</span><span style="line-height: 21px;">Y</span><span style="font-family: 宋体; line-height: 21px;">顶点的</span><span style="line-height: 21px;">slack</span><span style="font-family: 宋体; line-height: 21px;">值中的最小值作为</span><span style="line-height: 21px;">d</span><span style="font-family: 宋体; line-height: 21px;">值即可。但还要注意一点：修改 顶标后，要把所有的</span><span style="line-height: 21px;">slack</span><span style="font-family: 宋体; line-height: 21px;">值都减去</span><span style="line-height: 21px;">d</span><span style="font-family: 宋体; line-height: 21px;">。</span></span>

	 

	原文:[http://www.360doc.com/content/11/0718/14/3701281_134273282.shtml](http://www.360doc.com/content/11/0718/14/3701281_134273282.shtml)

	 